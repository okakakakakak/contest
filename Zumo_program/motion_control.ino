/*
 * motion_control.ino
 * 
 * 【機能概要】
 * PI制御を使用した方位制御を実装するモジュール
 * 
 * 【主要機能】
 * turnTo(): 目標方位に向かって旋回するための制御入力を計算
 */

#include "definitions.h"

// ============================================
// PI制御による方位制御
// ============================================
/**
 * 目標方位に向かって旋回するための制御入力を計算する
 * PI制御（比例積分制御）を使用して安定した方位制御を実現
 * 
 * 【動作】
 * - 誤差が大きい場合（>45度）：P制御のみ（高速旋回）
 * - 誤差が小さい場合（<=45度）：PI制御（精密制御）
 * 
 * @param target_heading 目標方位角（度、0〜360）
 * @return 制御入力 u（正：左旋回、負：右旋回、範囲：-180〜180）
 */
float turnTo(float target_heading) {
  // ========================================
  // ステップ1: 現在の方位角を更新
  // ========================================
  // 地磁気センサーから最新の方位角を取得し、磁気偏角で補正
  compass_state.updateHeading(MAGNETIC_DECLINATION);
  
  // ロボットの時刻を更新（制御周期の計算に使用）
  robot_state.updateTime();
  
  // ========================================
  // ステップ2: 方位角誤差を計算
  // ========================================
  // 誤差 = 目標方位角 - 現在の方位角
  float e = target_heading - compass_state.current_heading;
  
  // 角度誤差を-180〜180度の範囲に正規化
  // 例：誤差が+200度の場合、-160度に変換（短い方の回転角を使用）
  while (e < -180) e += 360;  // -180度未満なら360度を加算
  while (e > 180) e -= 360;   // +180度超過なら360度を減算
  
  // ========================================
  // ステップ3: 制御入力を計算
  // ========================================
  float u;  // 制御入力
  
  if (abs(e) > 45.0) {
    // ========================================
    // |e|>45° の場合はP制御（比例制御のみ）
    // ========================================
    // 誤差が大きいときは積分項を使わず、素早く旋回
    u = pi_ctrl.kp * e;
    
    // 積分項をリセット（大きな誤差では積分を蓄積しない）
    pi_ctrl.sum_e = 0;
    
  } else {
    // ========================================
    // |e|<=45° の場合はPI制御（比例積分制御）
    // ========================================
    // 誤差が小さいときは積分項を使用して精密に制御
    
    // 積分項を更新：sum_e += (ti_inv * e * Δt)
    // ti_inv: 積分時間の逆数
    // e: 現在の誤差
    // Δt: 前回からの経過時間（time_now - time_prev）
    pi_ctrl.sum_e += pi_ctrl.ti_inv * e * (robot_state.time_now - robot_state.time_prev);
    
    // アンチワインドアップ：積分項を制限して過度な蓄積を防ぐ
    // 積分項が大きくなりすぎると、制御が不安定になる
    pi_ctrl.sum_e = constrain(pi_ctrl.sum_e, -50, 50);
    
    // 制御入力の計算：u = kp * (e + sum_e)
    // 比例項（kp * e）と積分項（kp * sum_e）の和
    u = pi_ctrl.kp * (e + pi_ctrl.sum_e);
  }
  
  // ========================================
  // ステップ4: 制御入力の制限
  // ========================================
  // 制御入力を-180〜180の範囲に制限（過度な制御を防ぐ）
  u = constrain(u, -180, 180);
  
  // 制御入力を返す
  // 呼び出し側でこの値を使ってモーター速度を調整する
  return u;
}